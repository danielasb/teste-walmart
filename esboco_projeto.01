# teste-walmart
Teste Prático Walmart
Walmart - Projeto de Automação de Testes com Cucumber
Atualmente, utilizamos Cucumber como nosso framework de automação e a idéia é avaliar como o candidato se adaptaria ao mesmo. O tempo máximo para envio do link para baixarmos o projeto do Github é de uma semana corrida (mas pode enviar antes desse prazo também caso termine antes).

Criação de Projeto de Testes Automatizados - BDD com cucumber
O objetivo é criar um projeto de automação versionado no Github (https://github.com/), utilizando Cucumber, Capybara e HTTParty para automatizar cenários para as duas Features abaixo:
1 - No site do walmart.com.br, validar a seguinte sequência de ações:
	Procurar pelo termo "tv" na busca
	Validar que a busca teve resultados
	Clicar em um dos resultados e validar que a página do produto abriu corretamente
	Adicionar o Produto ao carrinho
	Abrir o carrinho e validar que o mesmo foi adicionado com sucesso

+# A sample Gemfile
+source "https://rubygems.org"
+
+gem "cucumber"
+gem "capybara"
+gem "selenium-webdriver"
+gem "httparty"


DEPENDENCIES
+  capybara
+  cucumber
+  httparty
+  selenium-webdriver


carrinho_busca.feature

#language: pt

Funcionalidade: Adicionar Produto ao carrinho
	Cliente walmart.com realiza busca de TV
	adiciona o produto ao carrinho

Cenario: Adicionar Produto ao Carrinho
	Dado site do walmart
	E realizado busca por TV
	E clico em um resultado
	E valido a página
	E Adiciono o produto ao carrinho
	Então valido se o produto está no carrinho

+Given(/^Acesso pagina walmart.com.br $/) do
+    visit 'http://www.walmart.com.br'
+end
+
+Then(/^ Procurar por "([^"]*)"$/) do |searchText|
+    fill_in 'suggestion-search', :with => searchText
+end
+
+And(/^I will click button Procurar$/) do
+    click_button "Procurar"
+end
+        
+Then(/^I expect see "([^"]*)"$/) do |expectedText|
+    expect(page).to have_content(expectedText)
+end
+
+And(/^I will click the Smart TV link$/) do
+    find('.product-title', :text => 'TV LED 3D 55” LG 55LB6200 Full HD').click
+end
+
+And(/^I will click button Adicionar ao carrinho$/) do
+    click_button "Adicionar ao carrinho"
+end
+
+And(/^I will click button Continuar$/) do
+    click_button "Continuar"
+end
+
+And(/^I will click Meu carrinho$/) do
+    find('.number', :text => '1').click
+end
+     
+Then(/^I expect see \/TV LED 3D 55” LG 55LB6200 Full HD (\d+)"\/$/) do |expectedText|
+    expect(page).to have_content(expectedText)
+end 

env.rb
+require 'capybara/cucumber'
+#require 'capybara/poltergeist' #executar modo headless
+ 
+Capybara.default_driver = :selenium 
+
+#executar modo headless
+#Capybara.javascript_driver = :poltergeist
2 - Os correios possuem uma API pública, que dado um determinado CEP, ela te retorna as informações do mesmo. O modelo da chamada é o seguinte:
GET na url http://cep.correiocontrol.com.br/$CEP_A_SER_TESTADO.json - substitua $CEP_A_SER_TESTADO pelo cep que desejar validar. 
Exemplo:
GET - http://cep.correiocontrol.com.br/13040089.json
Resposta:
{
    bairro: "Jardim Nova Europa",
    logradouro: "Rua Manoel Sylvestre de Freitas Filho",
    cep: "13040089",
    uf: "SP",
    localidade: "Campinas"
}
 A partir das informações acima, implemente cenários de teste que valide uma chamada com um cep válido e outra com cep inválido para essa API (implemente quantos cenários achar interessante, sempre validando o status code HTTP da resposta).
 ps: É importante validar individualmente cada campo do JSON de resposta.


GET - http://cep.correiocontrol.com.br/69900034.json
Resposta:
{
    bairro: "Base",
    logradouro: "Avenida Epaminondas Jácome - de 3122 ao fim",
    cep: "69900034",
    uf: "AC",
    localidade: "Rio Branco"
}



GET - http://cep.correiocontrol.com.br/000000000.json
Resposta:
{
	Menssage: "O endereço informado 000000000 não foi encontrado",
}


